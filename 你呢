<!DOCTYPE html>

<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixiJS v8 跟手粒子拖尾效果</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/8.0.4/pixi.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            border: 2px solid #333;
            border-radius: 10px;
        }
        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        .control-group {
            margin: 5px 0;
        }
        label {
            display: inline-block;
            width: 120px;
        }
        input[type="range"] {
            width: 100px;
        }
        input[type="number"] {
            width: 60px;
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 2px;
        }
        .sprite-selector {
            margin: 10px 0;
        }
        .sprite-option {
            display: inline-block;
            margin: 2px;
            padding: 5px 8px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .sprite-option.active {
            background: #4ECDC4;
            border-color: #4ECDC4;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div class="controls">
        <div class="control-group">
            <label>粒子数量:</label>
            <input type="range" id="particleCount" min="1" max="50" value="10">
            <span id="particleCountValue">10</span>
        </div>
        <div class="control-group">
            <label>生存时间(ms):</label>
            <input type="number" id="lifeTime" min="500" max="5000" value="2000">
        </div>
        <div class="control-group">
            <label>最小缩放:</label>
            <input type="range" id="minScale" min="0.1" max="2" step="0.1" value="0.3">
            <span id="minScaleValue">0.3</span>
        </div>
        <div class="control-group">
            <label>最大缩放:</label>
            <input type="range" id="maxScale" min="0.1" max="3" step="0.1" value="1.5">
            <span id="maxScaleValue">1.5</span>
        </div>
        <div class="sprite-selector">
            <label>粒子形状:</label><br>
            <div class="sprite-option active" data-shape="circle">圆形</div>
            <div class="sprite-option" data-shape="star">星形</div>
            <div class="sprite-option" data-shape="diamond">钻石</div>
            <div class="sprite-option" data-shape="heart">心形</div>
            <div class="sprite-option" data-shape="butterfly">蝴蝶</div>
        </div>
    </div>

```
<script>
    // 粒子拖尾效果类
    class ParticleTrail {
        constructor(app) {
            this.app = app;
            this.particles = [];
            this.particleContainer = new PIXI.Container();
            this.app.stage.addChild(this.particleContainer);
            
            // 存储不同形状的纹理
            this.textures = {};
            
            // 配置参数
            this.config = {
                particleCount: 10,    // 每次生成的粒子数量
                lifeTime: 2000,       // 粒子生存时间(ms)
                minScale: 0.3,        // 最小缩放
                maxScale: 1.5,        // 最大缩放
                currentShape: 'circle', // 当前粒子形状
                colors: [0xFF6B6B, 0x4ECDC4, 0x45B7D1, 0xF9CA24, 0xF0932B, 0xEB4D4B, 0x6C5CE7],
            };
            
            // 鼠标位置
            this.mousePos = { x: 0, y: 0 };
            this.lastMousePos = { x: 0, y: 0 };
            this.isMouseMoving = false;
            
            this.createTextures();
            this.setupEventListeners();
            this.animate();
        }
        
        // 创建不同形状的粒子纹理
        createTextures() {
            const shapes = ['circle', 'star', 'diamond', 'heart', 'butterfly'];
            
            shapes.forEach(shape => {
                this.textures[shape] = this.createShapeTexture(shape);
            });
        }
        
        // 创建指定形状的纹理
        createShapeTexture(shape) {
            const graphics = new PIXI.Graphics();
            const size = 40;
            const halfSize = size / 2;
            
            graphics.fill(0xFFFFFF);
            
            switch(shape) {
                case 'circle':
                    graphics.circle(halfSize, halfSize, halfSize * 0.8);
                    break;
                    
                case 'star':
                    this.drawStar(graphics, halfSize, halfSize, 5, halfSize * 0.8, halfSize * 0.4);
                    break;
                    
                case 'diamond':
                    graphics.moveTo(halfSize, 5);
                    graphics.lineTo(size - 5, halfSize);
                    graphics.lineTo(halfSize, size - 5);
                    graphics.lineTo(5, halfSize);
                    graphics.closePath();
                    break;
                    
                case 'heart':
                    this.drawHeart(graphics, halfSize, halfSize, halfSize * 0.6);
                    break;
                    
                case 'butterfly':
                    this.drawButterfly(graphics, halfSize, halfSize, halfSize * 0.8);
                    break;
            }
            
            return this.app.renderer.generateTexture(graphics);
        }
        
        // 绘制星形
        drawStar(graphics, x, y, points, outerRadius, innerRadius) {
            const step = Math.PI / points;
            const halfStep = step / 2;
            const start = -Math.PI / 2;
            
            graphics.moveTo(x + Math.cos(start) * outerRadius, y + Math.sin(start) * outerRadius);
            
            for (let i = 0; i < points; i++) {
                const angle1 = start + i * 2 * step + step;
                const angle2 = start + i * 2 * step + 2 * step;
                
                graphics.lineTo(x + Math.cos(angle1) * innerRadius, y + Math.sin(angle1) * innerRadius);
                graphics.lineTo(x + Math.cos(angle2) * outerRadius, y + Math.sin(angle2) * outerRadius);
            }
            
            graphics.closePath();
        }
        
        // 绘制心形
        drawHeart(graphics, x, y, size) {
            const heartPath = [];
            for (let t = 0; t < Math.PI * 2; t += 0.1) {
                const hx = 16 * Math.pow(Math.sin(t), 3);
                const hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                heartPath.push({x: x + hx * size / 16, y: y - hy * size / 16});
            }
            
            if (heartPath.length > 0) {
                graphics.moveTo(heartPath[0].x, heartPath[0].y);
                for (let i = 1; i < heartPath.length; i++) {
                    graphics.lineTo(heartPath[i].x, heartPath[i].y);
                }
                graphics.closePath();
            }
        }
        
        // 绘制蝴蝶
        drawButterfly(graphics, x, y, size) {
            // 上翅膀
            graphics.arc(x - size/4, y - size/4, size/3, 0, Math.PI);
            graphics.arc(x + size/4, y - size/4, size/3, 0, Math.PI);
            
            // 下翅膀
            graphics.arc(x - size/4, y + size/4, size/4, Math.PI, 2 * Math.PI);
            graphics.arc(x + size/4, y + size/4, size/4, Math.PI, 2 * Math.PI);
            
            // 身体
            graphics.rect(x - 2, y - size/2, 4, size);
        }
        
        // 创建单个粒子
        createParticle(x, y) {
            const texture = this.textures[this.config.currentShape];
            const particle = new PIXI.Sprite(texture);
            
            // 随机位置偏移
            const offsetX = (Math.random() - 0.5) * 100;
            const offsetY = (Math.random() - 0.5) * 100;
            
            particle.x = x + offsetX;
            particle.y = y + offsetY;
            particle.anchor.set(0.5);
            
            // 随机缩放
            const scale = this.config.minScale + Math.random() * (this.config.maxScale - this.config.minScale);
            particle.scale.set(scale);
            
            // 随机颜色
            const color = this.config.colors[Math.floor(Math.random() * this.config.colors.length)];
            particle.tint = color;
            
            // 粒子属性
            particle.birthTime = Date.now();
            particle.initialAlpha = 0.8 + Math.random() * 0.2;
            particle.alpha = particle.initialAlpha;
            particle.initialScale = scale;
            
            // 随机运动方向和速度
            particle.vx = (Math.random() - 0.5) * 2;
            particle.vy = (Math.random() - 0.5) * 2;
            
            // 旋转速度
            particle.rotationSpeed = (Math.random() - 0.5) * 0.1;
            
            this.particleContainer.addChild(particle);
            this.particles.push(particle);
        }
        
        // 生成粒子群
        emitParticles(x, y) {
            for (let i = 0; i < this.config.particleCount; i++) {
                this.createParticle(x, y);
            }
        }
        
        // 更新粒子
        updateParticles() {
            const currentTime = Date.now();
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const particle = this.particles[i];
                const age = currentTime - particle.birthTime;
                const lifeRatio = age / this.config.lifeTime;
                
                if (lifeRatio >= 1) {
                    // 粒子生命结束，移除
                    this.particleContainer.removeChild(particle);
                    particle.destroy();
                    this.particles.splice(i, 1);
                    continue;
                }
                
                // 更新位置
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // 更新旋转
                particle.rotation += particle.rotationSpeed;
                
                // 应用摩擦力
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                // 更新透明度（淡出效果）
                particle.alpha = particle.initialAlpha * (1 - lifeRatio);
                
                // 更新缩放（缩小效果）
                const scaleRatio = 1 - lifeRatio * 0.5;
                particle.scale.set(particle.initialScale * scaleRatio);
            }
        }
        
        // 设置事件监听
        setupEventListeners() {
            const canvas = this.app.canvas;
            
            // 鼠标移动事件
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                this.lastMousePos.x = this.mousePos.x;
                this.lastMousePos.y = this.mousePos.y;
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
                this.isMouseMoving = true;
            });
            
            // 鼠标离开画布
            canvas.addEventListener('mouseleave', () => {
                this.isMouseMoving = false;
            });
            
            // 鼠标进入画布
            canvas.addEventListener('mouseenter', (e) => {
                const rect = canvas.getBoundingClientRect();
                this.mousePos.x = e.clientX - rect.left;
                this.mousePos.y = e.clientY - rect.top;
                this.lastMousePos.x = this.mousePos.x;
                this.lastMousePos.y = this.mousePos.y;
            });
        }
        
        // 动画循环
        animate() {
            // 如果鼠标在移动，生成粒子
            if (this.isMouseMoving) {
                // 计算鼠标移动距离，距离越大生成越多粒子
                const dx = this.mousePos.x - this.lastMousePos.x;
                const dy = this.mousePos.y - this.lastMousePos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) { // 只有移动距离超过5像素才生成粒子
                    this.emitParticles(this.mousePos.x, this.mousePos.y);
                }
            }
            
            // 更新所有粒子
            this.updateParticles();
            
            // 检查鼠标是否停止移动
            if (Math.abs(this.mousePos.x - this.lastMousePos.x) < 1 && 
                Math.abs(this.mousePos.y - this.lastMousePos.y) < 1) {
                this.isMouseMoving = false;
            }
        }
        
        // 更新配置
        updateConfig(newConfig) {
            Object.assign(this.config, newConfig);
        }
        
        // 切换粒子形状
        changeShape(shape) {
            this.config.currentShape = shape;
        }
    }
    
    // 初始化PIXI应用 (v8语法)
    const app = new PIXI.Application();
    
    (async () => {
        await app.init({
            width: 800,
            height: 600,
            backgroundColor: 0x1a1a2e,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true
        });
        
        document.getElementById('gameContainer').appendChild(app.canvas);
        
        // 创建粒子拖尾效果
        const particleTrail = new ParticleTrail(app);
        
        // 添加到ticker
        app.ticker.add(() => {
            particleTrail.animate();
        });
        
        // 控制面板事件
        const particleCountSlider = document.getElementById('particleCount');
        const particleCountValue = document.getElementById('particleCountValue');
        const lifeTimeInput = document.getElementById('lifeTime');
        const minScaleSlider = document.getElementById('minScale');
        const minScaleValue = document.getElementById('minScaleValue');
        const maxScaleSlider = document.getElementById('maxScale');
        const maxScaleValue = document.getElementById('maxScaleValue');
        
        particleCountSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            particleCountValue.textContent = value;
            particleTrail.updateConfig({ particleCount: value });
        });
        
        lifeTimeInput.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            particleTrail.updateConfig({ lifeTime: value });
        });
        
        minScaleSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            minScaleValue.textContent = value;
            particleTrail.updateConfig({ minScale: value });
        });
        
        maxScaleSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            maxScaleValue.textContent = value;
            particleTrail.updateConfig({ maxScale: value });
        });
        
        // 形状选择器事件
        const shapeOptions = document.querySelectorAll('.sprite-option');
        shapeOptions.forEach(option => {
            option.addEventListener('click', (e) => {
                // 移除其他选项的active类
                shapeOptions.forEach(opt => opt.classList.remove('active'));
                // 添加当前选项的active类
                e.target.classList.add('active');
                // 更新粒子形状
                const shape = e.target.dataset.shape;
                particleTrail.changeShape(shape);
            });
        });
        
        // 添加说明文字
        const instructions = new PIXI.Text({
            text: '移动鼠标查看粒子拖尾效果',
            style: {
                fontFamily: 'Arial',
                fontSize: 24,
                fill: 0xffffff,
                alpha: 0.7
            }
        });
        instructions.anchor.set(0.5);
        instructions.x = app.screen.width / 2;
        instructions.y = app.screen.height / 2;
        app.stage.addChild(instructions);
        
        // 鼠标移动时隐藏说明文字
        app.canvas.addEventListener('mousemove', () => {
            instructions.alpha = Math.max(0, instructions.alpha - 0.02);
        });
    })();
</script>
```

</body>
</html>
