<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue3 JS控制坐标的滑动效果</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

```
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  min-height: 100vh;
  display: flex;
  align-items: center;
  justify-content: center;
}

.app {
  max-width: 800px;
  width: 100%;
  padding: 20px;
}

.title {
  text-align: center;
  color: white;
  font-size: 2.5rem;
  font-weight: bold;
  margin-bottom: 2rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.slider-wrapper {
  position: relative;
  height: 400px;
  background: white;
  border-radius: 20px;
  overflow: hidden;
  box-shadow: 0 20px 40px rgba(0,0,0,0.15);
  margin-bottom: 30px;
}

.slide-item {
  position: absolute;
  width: 100%;
  height: 100%;
  top: 0;
}

.container {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: white;
  text-align: center;
  border-radius: 20px;
}

.container h2 {
  font-size: 3rem;
  margin-bottom: 1rem;
  text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

.container p {
  font-size: 1.3rem;
  opacity: 0.9;
  max-width: 80%;
  line-height: 1.6;
}

.controls {
  display: flex;
  justify-content: center;
  gap: 30px;
  margin-bottom: 30px;
}

.control-btn {
  padding: 15px 30px;
  background: rgba(255, 255, 255, 0.2);
  color: white;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 50px;
  cursor: pointer;
  font-size: 1.1rem;
  font-weight: 600;
  backdrop-filter: blur(10px);
}

.control-btn:hover {
  background: rgba(255, 255, 255, 0.3);
}

.indicators {
  display: flex;
  justify-content: center;
  gap: 15px;
}

.indicator {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  cursor: pointer;
}

.indicator.active {
  background: white;
}
```

  </style>
</head>
<body>
  <div id="app">
    <div class="app">
      <h1 class="title">Vue3 JS控制坐标滑动效果</h1>

```
  <div class="slider-wrapper" ref="sliderWrapper">
    <div 
      v-for="(container, index) in containers" 
      :key="container.id"
      class="slide-item"
      :ref="el => setSlideRef(el, index)"
    >
      <div 
        class="container"
        :style="{ 
          background: container.gradient,
          left: getItemPosition(index) + 'px'
        }"
      >
        <h2>{{ container.title }}</h2>
        <p>{{ container.content }}</p>
      </div>
    </div>
  </div>

  <div class="controls">
    <button 
      class="control-btn" 
      @click="goToPrev"
      :disabled="isAnimating"
    >
      ← 向左滑动
    </button>
    <button 
      class="control-btn" 
      @click="goToNext"
      :disabled="isAnimating"
    >
      向右滑动 →
    </button>
  </div>

  <div class="indicators">
    <div 
      v-for="(container, index) in containers" 
      :key="index"
      class="indicator"
      :class="{ active: index === currentIndex }"
      @click="goToIndex(index)"
    />
  </div>

  <div style="margin-top: 30px; color: white; background: rgba(0,0,0,0.2); padding: 20px; border-radius: 10px;">
    <h3>当前状态：</h3>
    <p>当前索引: {{ currentIndex }}</p>
    <p>动画状态: {{ isAnimating ? '进行中' : '空闲' }}</p>
    <p>容器宽度: {{ containerWidth }}px</p>
    <p>动画进度: {{ animationProgress.toFixed(2) }}</p>
  </div>
</div>
```

  </div>

  <script>
    const { createApp, ref, reactive, computed, nextTick, onMounted } = Vue;

    createApp({
      setup() {
        // 响应式数据
        const currentIndex = ref(0);
        const isAnimating = ref(false);
        const containerWidth = ref(800);
        const animationProgress = ref(0);
        const slideRefs = reactive({});
        const sliderWrapper = ref(null);

        // 容器数据
        const containers = ref([
          {
            id: 1,
            title: '容器 1',
            content: '这是第一个容器的内容，通过JS控制坐标位置',
            gradient: 'linear-gradient(135deg, #ff6b6b, #ee5a52)'
          },
          {
            id: 2,
            title: '容器 2',
            content: '这是第二个容器的内容，完全不依赖CSS动画',
            gradient: 'linear-gradient(135deg, #4ecdc4, #44a08d)'
          },
          {
            id: 3,
            title: '容器 3',
            content: '这是第三个容器的内容，所有位置通过JavaScript计算',
            gradient: 'linear-gradient(135deg, #45b7d1, #2196f3)'
          },
          {
            id: 4,
            title: '容器 4',
            content: '这是第四个容器的内容，适用于非DOM元素',
            gradient: 'linear-gradient(135deg, #f093fb, #f5576c)'
          }
        ]);

        // 设置slide引用
        const setSlideRef = (el, index) => {
          if (el) {
            slideRefs[index] = el;
          }
        };

        // 获取容器位置
        const getItemPosition = (index) => {
          const offset = index - currentIndex.value;
          return offset * containerWidth.value;
        };

        // 动画函数
        const animateSlide = (direction, targetIndex) => {
          if (isAnimating.value) return;
          
          isAnimating.value = true;
          animationProgress.value = 0;
          
          const startTime = performance.now();
          const duration = 600; // 动画持续时间 600ms
          const startIndex = currentIndex.value;
          
          // 缓动函数 (easeInOutCubic)
          const easeInOutCubic = (t) => {
            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
          };

          const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easedProgress = easeInOutCubic(progress);
            
            animationProgress.value = progress;
            
            // 更新所有元素的位置
            containers.value.forEach((_, index) => {
              const slideElement = slideRefs[index];
              if (slideElement) {
                const containerElement = slideElement.querySelector('.container');
                if (containerElement) {
                  // 计算当前位置
                  let currentPos;
                  if (progress === 0) {
                    // 动画开始
                    currentPos = (index - startIndex) * containerWidth.value;
                  } else if (progress === 1) {
                    // 动画结束
                    currentPos = (index - targetIndex) * containerWidth.value;
                  } else {
                    // 动画进行中，插值计算
                    const startPos = (index - startIndex) * containerWidth.value;
                    const endPos = (index - targetIndex) * containerWidth.value;
                    currentPos = startPos + (endPos - startPos) * easedProgress;
                  }
                  
                  // 应用位置变换
                  containerElement.style.transform = `translateX(${currentPos}px)`;
                }
              }
            });
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // 动画结束
              currentIndex.value = targetIndex;
              isAnimating.value = false;
              animationProgress.value = 0;
              
              // 重置所有元素的transform，使用静态定位
              containers.value.forEach((_, index) => {
                const slideElement = slideRefs[index];
                if (slideElement) {
                  const containerElement = slideElement.querySelector('.container');
                  if (containerElement) {
                    containerElement.style.transform = '';
                  }
                }
              });
            }
          };
          
          requestAnimationFrame(animate);
        };

        // 导航方法
        const goToNext = () => {
          const targetIndex = (currentIndex.value + 1) % containers.value.length;
          animateSlide('left', targetIndex);
        };

        const goToPrev = () => {
          const targetIndex = (currentIndex.value - 1 + containers.value.length) % containers.value.length;
          animateSlide('right', targetIndex);
        };

        const goToIndex = (index) => {
          if (index === currentIndex.value || isAnimating.value) return;
          const direction = index > currentIndex.value ? 'left' : 'right';
          animateSlide(direction, index);
        };

        // 初始化
        onMounted(() => {
          if (sliderWrapper.value) {
            containerWidth.value = sliderWrapper.value.offsetWidth;
          }
          
          // 监听窗口大小变化
          const handleResize = () => {
            if (sliderWrapper.value) {
              containerWidth.value = sliderWrapper.value.offsetWidth;
            }
          };
          
          window.addEventListener('resize', handleResize);
        });

        return {
          currentIndex,
          isAnimating,
          containerWidth,
          animationProgress,
          containers,
          sliderWrapper,
          setSlideRef,
          getItemPosition,
          goToNext,
          goToPrev,
          goToIndex
        };
      }
    }).mount('#app');
  </script>

</body>
</html>
